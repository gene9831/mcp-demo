# useMessage 支持工具调用

- handleSSEStream 逻辑重构 -> processSSEStream
- 工具调用使用插件集成
- 多个工具同时调用
- 工具可取消调用（工具实际请求不取消，可以取消当前对话流程）

## 问题

- ✅工具调用用户禁止，保留工具调用消息
- ❓工具调用只保留结果，用于下一次回话
  应该让开发者自行过滤，（提供此特性可选？）
- 如果工具调用也根据signal中断，会不会提前抛出错误？(用fetch工具测试，使用signal取消请求，看是否抛出错误)

## 完整生命周期流程

```text
sendMessage/send (用户调用)
    ↓
1. onTurnStart (串行执行，可返回清理函数)
    ↓
2. onBeforeRequest (串行执行，可修改 requestBody)
    ↓
发起请求，开始流式响应
    ↓
3. onSSEStreamData (每个 SSE 数据块触发)
    ↓
流式响应结束
    ↓
4. onAfterRequest (并行执行，可返回 Message[])
    ↓
返回新消息?
    ├─ 是 → 2. onBeforeRequest
    └─ 否 → 5. onTurnEnd (串行执行)
    ↓
执行清理函数 (如有)
    ↓
完成
```

## 关键钩子函数说明

### 1. onTurnStart

- **时机**: 用户消息入队后，正式发起请求之前
- **执行方式**: 串行执行（按插件注册顺序），有错误则中断，整个流程结束。
- **返回值**: 可选的清理函数，会在 finally 块中执行（LIFO 顺序）

### 2. onBeforeRequest

- **时机**: requestBody 已创建，正式发起请求之前
- **执行方式**: 串行执行（避免并发修改 requestBody），有错误则中断，整个流程结束。
- **用途**: 增补 tools、注入上下文参数、参数校验等

### 3. onSSEStreamData

- **时机**: 接收到每个 SSE 数据块时
- **执行方式**: 每个数据块都会触发所有插件
- **用途**: 自定义增量合并、实时 UI 效果等

### 4. onAfterRequest

- **时机**: 本次请求（含流式）结束后
- **执行方式**: 并行执行（Promise.all），任一插件抛错将中断本轮流程
- **返回值**: Message[] 或 null，会被扁平化合并
- **特殊处理**: 如果有返回消息，会自动触发新一轮请求（递归）
  - 递归请求从 `onBeforeRequest` 开始执行

### 5. onTurnEnd

- **时机**: 本轮对话完成（成功、失败或被中止）后，在执行清理函数之前
- **执行方式**: 串行执行（不依赖 onTurnStart 是否成功），有错误则中断，整个流程结束。

## 清理函数执行顺序

清理函数采用 **LIFO（后进先出）** 策略：

- 插件 A 的清理函数先注册
- 插件 B 的清理函数后注册
- 执行顺序：B → A（逆序执行）
